# Groth16 + Circom + Arkworks + Circom-Witnesscalc + WASM

This repo is designed to make using Circom in the browser with Rust and WASM easier and simpler. Instead of using arkworks-circom we instead use arkworks together with circom-witnesscalc directly from Rust. This makes it compatible with wasm-pack by avoiding some complex dependencies used by arkworks-circom (wasmer).

Note, when using this repo, you may have to use a Cargo patch to replace deep dependencies of circom-witnesscalc to enable building with `wasm-pack`:

```toml
[patch.crates-io]
circom-witnesscalc = { git = "https://github.com/HarryR/circom-witnesscalc" }
```

## Command-line Utilities

### `ark_cwc_setup`

Take the `.r1cs` file generated by Circom, and output an Arkworks compatible proving and verifying keys.

### `ark_cwc_prove`

Takes as inputs:

 * `input.json` - Dictionary of witnesses (in standard SnarkJS compatible format?)
 * `input.graph` - The compiled circom-witnesscalc binary graph
 * `input.r1cs` - The R1CS file compiled from Circom
 * `input.pkey` - The Arkworks binary proving key (from `ark_cwc_setup`)

It outputs

 * `proof.json` - easy JSON format
 * `proof.bin` - Arkworks binary proof struct

## Usage from Rust

There are two main functions:

### `ark_circom_witnesscalc::proof_oneshot`

Accepts strings & byte arrays as its arguments, this allows you to embed the necessary files in your WASM file or other program, meaning there is no need for external file I/O. For example:

```rust
let (proof, public_inputs) = proof_oneshot(&inputs_data, &PKEY_DATA, &GRAPH_DATA, &R1CS_DATA)?;
```

### `ark_circom_witnesscalc::proof_to_json`

Converts the resulting proof to JSON format, for easy parsing in your JS (or other) app.

```rust
let proof_json = proof_to_json(&proof, &public_inputs)?;
```

# Full Example

## Circuit Setup

Say we have a Circom circuit `multiply.circom`

```circom
pragma circom 2.0.0;

template Multiply() {
    signal input a;
    signal input b;
    signal output c;
    c <== a*b;
 }

 component main {public [a]} = Multiply();
```

We then use the `build-circuit` file from circom-witnesscalc, an example `Makefile` I use assumes you checkout my fork of `circom-witnesscalc` from `https://github.com/HarryR/circom-witnesscalc/`

```make
BUILD_CIRCUIT = ./circom-witnesscalc/target/release/build-circuit

build:
	mkdir -p build

.PRECIOUS: build/%.graph build/%.r1cs
build/%.graph build/%.r1cs: %.circom $(BUILD_CIRCUIT) build
	$(BUILD_CIRCUIT) --r1cs build/$*.r1cs $< build/$*.graph
```

We can then run this to generate the `.r1cs` and `.graph` files in `build/`:

```
make build/multiply.r1cs
```

Then generate the proving key for your circuit, using `ark_cwc_setup`, I use this makefile fragment:

```make
ARK_CWC_SETUP = ./ark-circom-witnesscalc/target/release/ark_cwc_setup

.PRECIOUS: build/%.ark-pkey build/%.ark-vk build/%.ark-vk-json
build/%.ark-pkey build/%.ark-vk: build/%.r1cs
	$(ARK_CWC_SETUP) $< build/$*.ark-pkey build/$*.ark-vk build/$*.ark-vk-json
```

And run it using the following, to generate the `.ark-pkey` file:

```bash
make build/example.ark-pkey
```

## Rust Integration & WASM Build

We can then define a library as such as follows, which accepts the proof inputs as a JSON string, and returns the proof as a JSON string. This is ideal when embedding the necessary files in your library to produce a single `.wasm`, `.so` or `.dll` file with everything included:

```rust
static PKEY_DATA: &[u8] = include_bytes!("../build/multiply.ark-pkey");
static GRAPH_DATA: &[u8] = include_bytes!("../build/multiply.graph");
static R1CS_DATA: &[u8] = include_bytes!("../build/multiply.r1cs");

use ark_circom_witnesscalc::{proof_oneshot, proof_to_json};

#[wasm_bindgen]
pub fn prove_example(inputs_data: &str) -> String {
    let (proof, public_inputs) = proof_oneshot(&inputs_data, &PKEY_DATA, &GRAPH_DATA, &R1CS_DATA)?;

    proof_to_json(&proof, &public_inputs)?
}
```

You can then build this with `wasm-pack` using:

```bash
wasm-pack build --target web
```

Then use the resulting `./pkg/example.js` in your HTML, like:

```html
<div>
    <input type="text" id="input" placeholder="Enter your proof inputs" value="">
    <button onclick="processText()">Process</button>
</div>

<script type="module">
    import init, { process_string } from './pkg/example.js';
    
    async function run() {
        // Initialize the wasm module
        await init();
        
        // Make the function available globally
        window.processText = function() {
            const input = document.getElementById('input').value;
            const result = prove_example(input);
            document.getElementById('result').textContent = result;
        };
        
        console.log('WASM module loaded successfully!');
    }
    
    run();
</script>
```

And we can provide the proof inputs as JSON to the form field, for example:

```json
{"a": "11", "b": "10"}
```