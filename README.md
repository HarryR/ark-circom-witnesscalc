# Groth16 + Circom + Arkworks + Circom-Witnesscalc + WASM

This repo is designed to make using Circom in the browser with Rust and WASM easier and simpler. Instead of using arkworks-circom we instead use arkworks together with circom-witnesscalc directly from Rust. This makes it compatible with wasm-pack by avoiding some complex dependencies used by arkworks-circom (wasmer).

Note, when using this repo, you may have to use a Cargo patch to replace deep dependencies of circom-witnesscalc to enable building with `wasm-pack`:

```toml
[patch.crates-io]
circom-witnesscalc = { git = "https://github.com/HarryR/circom-witnesscalc" }
```

## Command-line Utilities

### `ark_cwc_setup`

Take the `.r1cs` file generated by Circom, and output an Arkworks compatible proving and verifying keys.

### `ark_cwc_prove`

Takes as inputs:

 * `input.json` - Dictionary of witnesses (in standard SnarkJS compatible format?)
 * `input.graph` - The compiled circom-witnesscalc binary graph
 * `input.r1cs` - The R1CS file compiled from Circom
 * `input.pkey` - The Arkworks binary proving key (from `ark_cwc_setup`)

It outputs

 * `proof.json` - easy JSON format
 * `proof.bin` - Arkworks binary proof struct

### `ark_cwc_verify_json`

Takes as inputs:

 * `proof.json` - Output from `ark_cwc_prove`
 * `vk.json` - Output from `ark_cwc_setup`

## Usage from Rust

There are two main functions:

### `ark_circom_witnesscalc::proof_oneshot`

Accepts strings & byte arrays as its arguments, this allows you to embed the necessary files in your WASM file or other program, meaning there is no need for external file I/O. For example:

```rust
let (proof, public_inputs) = proof_oneshot(&inputs_data, &PKEY_DATA, &GRAPH_DATA, &R1CS_DATA)?;
```

### `ark_circom_witnesscalc::proof_to_json`

Converts the resulting proof to JSON format, for easy parsing in your JS (or other) app.

```rust
let proof_json = proof_to_json(&proof, &public_inputs)?;
```

# Full Example

## Circuit Setup

Say we have a Circom circuit `multiply.circom`

```circom
pragma circom 2.0.0;

template Multiply() {
    signal input a;
    signal input b;
    signal output c;
    c <== a*b;
 }

 component main {public [a]} = Multiply();
```

We then use the `build-circuit` file from circom-witnesscalc, an example `Makefile` I use assumes you checkout my fork of `circom-witnesscalc` from `https://github.com/HarryR/circom-witnesscalc/`

```make
BUILD_CIRCUIT = ./circom-witnesscalc/target/release/build-circuit

build:
	mkdir -p build

.PRECIOUS: build/%.graph build/%.r1cs
build/%.graph build/%.r1cs: %.circom $(BUILD_CIRCUIT) build
	$(BUILD_CIRCUIT) --r1cs build/$*.r1cs $< build/$*.graph
```

We can then run this to generate the `.r1cs` and `.graph` files in `build/`:

```
make build/multiply.r1cs
```

Then generate the proving key for your circuit, using `ark_cwc_setup`, I use this makefile fragment:

```make
ARK_CWC_SETUP = ./ark-circom-witnesscalc/target/release/ark_cwc_setup

.PRECIOUS: build/%.ark-pkey build/%.ark-vk build/%.ark-vk-json
build/%.ark-pkey build/%.ark-vk: build/%.r1cs
	$(ARK_CWC_SETUP) $< build/$*.ark-pkey build/$*.ark-vk build/$*.ark-vk-json
```

And run it using the following, to generate the `.ark-pkey` file:

```bash
make build/example.ark-pkey
```

## Rust Integration & WASM Build

We can then define a library as such as follows, which accepts the proof inputs as a JSON string, and returns the proof as a JSON string. This is ideal when embedding the necessary files in your library to produce a single `.wasm`, `.so` or `.dll` file with everything included:

```rust
static PKEY_DATA: &[u8] = include_bytes!("../build/multiply.ark-pkey");
static GRAPH_DATA: &[u8] = include_bytes!("../build/multiply.graph");
static R1CS_DATA: &[u8] = include_bytes!("../build/multiply.r1cs");

use ark_circom_witnesscalc::{proof_oneshot, proof_to_json};

#[wasm_bindgen]
pub fn prove_example(inputs_data: &str) -> String {
    let (proof, public_inputs) = proof_oneshot(&inputs_data, &PKEY_DATA, &GRAPH_DATA, &R1CS_DATA)?;

    proof_to_json(&proof, &public_inputs)?
}
```

You can then build this with `wasm-pack` using:

```bash
wasm-pack build --target web
```

Then use the resulting `./pkg/example.js` in your HTML, like:

```html
<div>
    <input type="text" id="input" placeholder="Enter your proof inputs" value="">
    <button onclick="processText()">Process</button>
</div>

<script type="module">
    import init, { process_string } from './pkg/example.js';
    
    async function run() {
        // Initialize the wasm module
        await init();
        
        // Make the function available globally
        window.processText = function() {
            const input = document.getElementById('input').value;
            const result = prove_example(input);
            document.getElementById('result').textContent = result;
        };
        
        console.log('WASM module loaded successfully!');
    }
    
    run();
</script>
```

And we can provide the proof inputs as JSON to the form field, for example:

```json
{"a": "11", "b": "10"}
```

# Solidity Compatibility

Remember, the G2 coefficients in arkworks-rs are `[c0,c1]`, wheras the EVM `ECPAIRING` opcode expects them to be `[c1,c0]`. The following code can help you convert between formats when using TypeScript:

```typescript
type ARK_CWC_G1 = [string,string,string];
type ARK_CWC_G2 = [[string,string],[string,string],[string,string]];

interface ARK_CWC_VerifyingKey {
    protocol: string,
    curve: string,
    nPublic: number,
    vk_alpha_1: ARK_CWC_G1,
    vk_beta_2: ARK_CWC_G2,
    vk_gamma_2: ARK_CWC_G2,
    vk_delta_2: ARK_CWC_G2,
    IC: ARK_CWC_G1[],
}

interface ARK_CWC_Proof {
    protocol: string,
    curve: string,
    type: string,
    a: ARK_CWC_G1,
    b: ARK_CWC_G2,
    c: ARK_CWC_G1,
    inputs: string[]
}

function swap_c0_c1(f:[string,string]): [string,string] {
    return [f[1], f[0]];
}

function ark_g1_to_sol(p:ARK_CWC_G1) {
    return {'X': p[0], 'Y': p[1]};
}

function ark_g2_to_sol(p:ARK_CWC_G2) {
    return {'X': swap_c0_c1(p[0]), 'Y': swap_c0_c1(p[1])};
}
```

For example:

```typescript
import { readFile } from 'node:fs/promises';
const proof: ARK_CWC_Proof = JSON.parse((await readFile('proof.json')).toString());
await contract.verify(proof.inputs, {
    'A': awk_g1_to_sol(proof.a),
    'B': awk_g2_to_sol(proof.b),
    'C': awk_g1_to_sol(proof.c),
});
```